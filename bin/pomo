#!/usr/bin/env bash
# be strict but do not exit on non-zero to keep interactive flows alive
set -uo pipefail

# --- Config & Paths ---
APP_NAME="Pomodoro Timer"
TOMATO="üçÖ"
XDG_CONFIG_HOME_DEFAULT="$HOME/.config"
CONFIG_DIR="${XDG_CONFIG_HOME:-$XDG_CONFIG_HOME_DEFAULT}/pomo"
TASKS_FILE="$CONFIG_DIR/tasks.txt"
STATE_FILE="$CONFIG_DIR/state"
ICON_PATH="pomodoro.png"

# Durations (minutes)
POMODORO_DURATION=25
SHORT_BREAK=5
LONG_BREAK=15
POMODOROS_BEFORE_LONG_BREAK=4

mkdir -p "$CONFIG_DIR"
declare -a TASKS=()

# --- Colors ---
# Basic ANSI colors; fall back to plain if not a TTY
if [[ -t 1 ]]; then
  RED=$'\033[31m'
  GREEN=$'\033[32m'
  YELLOW=$'\033[33m'
  BLUE=$'\033[34m'
  MAGENTA=$'\033[35m'
  CYAN=$'\033[36m'
  RESET=$'\033[0m'
else
  RED=""; GREEN=""; YELLOW=""; BLUE=""; MAGENTA=""; CYAN=""; RESET=""
fi

status_tag() {
  # usage: status_tag LABEL COLOR
  local label=$1; local color=${2-}
  printf "[%s%s%s]" "$color" "$label" "$RESET"
}

mode_tag() {
  # usage: mode_tag MODE
  case "$1" in
    work)  status_tag "Work" "$BLUE" ;;
    short) status_tag "Short Break" "$CYAN" ;;
    long)  status_tag "Long Break" "$MAGENTA" ;;
    *)     status_tag "Session" "$BLUE" ;;
  esac
}

# --- Helpers ---
trim_ws() {
  local s="${1-}"
  # trim leading whitespace
  s="${s#${s%%[!$' \t\r\n']*}}"
  # trim trailing whitespace
  s="${s%${s##*[!$' \t\r\n']}}"
  printf "%s" "$s"
}

sanitize_tasks() {
  local cleaned=()
  for t in "${TASKS[@]:-}"; do
    [[ -z "$t" ]] && continue
    local st="${t%%|*}"; local nm="${t#*|}"
    nm="$(trim_ws "$nm")"
    [[ -z "$nm" ]] && continue
    case "$st" in
      P|D|C) ;;
      *) st="P";;
    esac
    cleaned+=("$st|$nm")
  done
  TASKS=("${cleaned[@]:-}")
}

# --- Tasks persistence ---
# tasks.txt format: STATUS|TASK NAME
# STATUS: P=pending, D=done, C=cancelled

load_tasks() {
  TASKS=()
  if [[ -f "$TASKS_FILE" ]]; then
    while IFS= read -r line; do
      [[ -z "$line" ]] && continue
      TASKS+=("$line")
    done < "$TASKS_FILE"
  fi
  sanitize_tasks
}

save_tasks() {
  : > "$TASKS_FILE"
  for t in "${TASKS[@]:-}"; do
    [[ -z "$t" ]] && continue
    local st="${t%%|*}"; local nm="${t#*|}"
    [[ -z "$nm" ]] && continue
    echo "$st|$nm" >> "$TASKS_FILE"
  done
}

print_tasks() {
  printf "Tasks:\n"
  local i=1
  for t in "${TASKS[@]:-}"; do
    [[ -z "$t" ]] && continue
    local status=${t%%|*}
    local name=${t#*|}
    [[ -z "$name" ]] && continue
    local marker="[ ]"
    if [[ "$status" == "D" ]]; then marker="[‚úì]"; fi
    if [[ "$status" == "C" ]]; then marker="[ ] cancelled:"; fi
    printf "%2d. %s %s\n" "$i" "$marker" "$name"
    ((i++))
  done
  [[ ${#TASKS[@]:-0} -eq 0 ]] && echo "(no tasks)"
}

add_tasks_interactive() {
  while true; do
    read -rp "Enter task name (blank to stop): " name || true
    if [[ -z "$name" ]]; then
      break
    fi
    name="$(trim_ws "$name")"
    [[ -z "$name" ]] && continue
    TASKS+=("P|$name")
    save_tasks
    read -rp "Add another? (y/N): " ans || true
    [[ "$ans" =~ ^[Yy]$ ]] || break
  done
  sanitize_tasks; save_tasks
}

delete_task() {
  print_tasks
  read -rp "Enter task number to delete: " idx || return 0
  if [[ "$idx" =~ ^[0-9]+$ ]] && (( idx>=1 && idx<=${#TASKS[@]:-0} )); then
    local new=()
    local i=1
    for entry in "${TASKS[@]:-}"; do
      if (( i != idx )); then new+=("$entry"); fi
      ((i++))
    done
    TASKS=("${new[@]:-}")
    save_tasks
  else
    echo "Invalid index."
  fi
}

mark_done() {
  print_tasks
  read -rp "Enter task number to mark done: " idx || return 0
  if [[ "$idx" =~ ^[0-9]+$ ]] && (( idx>=1 && idx<=${#TASKS[@]:-0} )); then
    local entry="${TASKS[idx-1]}"; local name=${entry#*|}
    TASKS[idx-1]="D|$name"; save_tasks; printf "Marked done - %s\n" "$(status_tag Done \"$GREEN\")"
  else
    echo "Invalid index."
  fi
}

mark_cancelled() {
  print_tasks
  read -rp "Enter task number to cancel: " idx || return 0
  if [[ "$idx" =~ ^[0-9]+$ ]] && (( idx>=1 && idx<=${#TASKS[@]:-0} )); then
    local entry="${TASKS[idx-1]}"; local name=${entry#*|}
    TASKS[idx-1]="C|$name"; save_tasks; echo "Cancelled."
  else
    echo "Invalid index."
  fi
}

first_pending_index() {
  local i=0
  for entry in "${TASKS[@]:-}"; do
    if [[ "${entry%%|*}" == "P" ]]; then echo "$i"; return; fi
    ((i++))
  done
  echo -1
}

clear_tasklist() {
  read -rp "Clear ALL tasks and reset state? (y/N): " ans || true
  if [[ "$ans" =~ ^[Yy]$ ]]; then
    TASKS=()
    : > "$TASKS_FILE"
    clear_state
    echo "Task list cleared."
    sleep 1
  fi
}

# --- Notifications ---
notify() {
  local title=$1 msg=$2
  if [[ "$OSTYPE" == darwin* ]]; then
    osascript -e "display notification \"$msg\" with title \"$title\"" || true
  elif [[ "$OSTYPE" == linux-gnu* ]]; then
    command -v notify-send >/dev/null 2>&1 && notify-send -i "$ICON_PATH" "$title" "$msg" || true
  fi
}

# --- Session state persistence ---
# STATE_FILE format:
# MODE=work|short|long
# REMAINING=seconds
# ACTIVE_TASK_INDEX=int
# POMODORO_COUNT=int
# ACTIVE=0|1

save_state() {
  cat > "$STATE_FILE" <<EOF
MODE=$MODE
REMAINING=$REMAINING
ACTIVE_TASK_INDEX=$ACTIVE_TASK_INDEX
POMODORO_COUNT=$POMODORO_COUNT
ACTIVE=$ACTIVE
EOF
}

load_state() {
  if [[ -f "$STATE_FILE" ]]; then
    # shellcheck disable=SC1090
    source "$STATE_FILE" || true
  fi
  MODE=${MODE:-work}
  REMAINING=${REMAINING:-0}
  ACTIVE_TASK_INDEX=${ACTIVE_TASK_INDEX:-0}
  POMODORO_COUNT=${POMODORO_COUNT:-0}
  ACTIVE=${ACTIVE:-0}
}

clear_state() {
  ACTIVE=0
  REMAINING=0
  ACTIVE_TASK_INDEX=-1
  save_state
}

# --- Timer/Session ---
format_mmss() { printf "%02d:%02d" $(( $1 / 60 )) $(( $1 % 60 )); }

title_for_mode() {
  case "$1" in
    work) echo "Work session";;
    short) echo "Short break";;
    long) echo "Long break";;
    *) echo "Session";;
  esac
}

countdown_loop() {
  ACTIVE=1; save_state
  while (( REMAINING > 0 )); do
    # Render timer line in place and clear the rest of the line
    printf "\r\033[K%s - %s - %s remaining" "$TOMATO" "$MODE_TITLE" "$(format_mmss "$REMAINING")"

    # Read a single key with 1s timeout; only act on key if read succeeded
    key=""
    if read -rsn1 -t 1 key; then
      case "$key" in
        p|$'\e')
          # Pause (triggered by 'p' or Esc)
          save_state
          # Overwrite active line with paused indicator
          printf "\r\033[K%s - %s - %s remaining - %s %s" \
            "$TOMATO" "$MODE_TITLE" "$(format_mmss "$REMAINING")" \
            "$(status_tag Paused \"$RED\")" "$(mode_tag "$MODE")"
          while true; do
            read -rsn1 k2
            if [ "$k2" = "r" ]; then
              # Flash a yellow [Resume] tag briefly, then redraw normal line
              printf "\r\033[K%s - %s - %s remaining - %s %s" \
                "$TOMATO" "$MODE_TITLE" "$(format_mmss "$REMAINING")" \
                "$(status_tag Resume \"$YELLOW\")" "$(mode_tag "$MODE")"
              sleep 0.35
              printf "\r\033[K%s - %s - %s remaining" \
                "$TOMATO" "$MODE_TITLE" "$(format_mmss "$REMAINING")"
              break
            elif [ "$k2" = $'\e' ] || [ "$k2" = "q" ]; then
              echo
              save_state
              return 1
            fi
          done
          # Continue loop without decrementing after resume
          continue
          ;;
        q)
          echo
          save_state
          return 1
          ;;
      esac
      # Any other key pressed while running is ignored
    else
      # Timeout (no key): tick the timer
      REMAINING=$((REMAINING - 1))
      save_state
      continue
    fi

    # If we got here via a keypress that wasn't handled above, just loop
    # without decrementing to avoid accidental double-handling
    continue
  done
  echo
  return 0
}

start_session() {
  local duration=$1; MODE=$2; MODE_TITLE=$3
  REMAINING=$((duration * 60))
  ACTIVE=1
  save_state
  notify "$APP_NAME" "$MODE_TITLE started"
  # Show instructions first
  echo "Press 'p' to pause, 'r' to resume, 'q' to quit, 'Esc' for menu."
  # Show initial timer display with a green [Start] tag
  printf "%s - %s - %s remaining - %s %s" \
    "$TOMATO" "$MODE_TITLE" "$(format_mmss "$REMAINING")" \
    "$(status_tag Start \"$GREEN\")" "$(mode_tag "$MODE")"
  countdown_loop || return 1
  ACTIVE=0; save_state
  return 0
}

complete_work_flow() {
  # mark active task done if valid
  if (( ACTIVE_TASK_INDEX >= 0 && ACTIVE_TASK_INDEX < ${#TASKS[@]} )); then
    local entry="${TASKS[$ACTIVE_TASK_INDEX]}"; local name=${entry#*|}
    TASKS[$ACTIVE_TASK_INDEX]="D|$name"; save_tasks
    printf "\nCompleted task: %s - %s\n" "$name" "$(status_tag Done \"$GREEN\")"
  fi
  ((POMODORO_COUNT++))
  save_state
  # decide next break
  if (( POMODORO_COUNT % POMODOROS_BEFORE_LONG_BREAK == 0 )); then
    start_session "$LONG_BREAK" long "Long break" || return 1
  else
    start_session "$SHORT_BREAK" short "Short break" || return 1
  fi
}

ensure_task_for_start() {
  load_tasks
  local pending_idx; pending_idx=$(first_pending_index)
  if (( pending_idx == -1 )); then
    echo "No tasks found. Add at least one task."
    add_tasks_interactive
    pending_idx=$(first_pending_index)
    if (( pending_idx == -1 )); then
      echo "No pending tasks to start."; return 1
    fi
  fi
  ACTIVE_TASK_INDEX=$pending_idx
  save_state
  return 0
}

resume_session_if_any() {
  load_state
  if [[ "${ACTIVE:-0}" == "1" && ${REMAINING:-0} -gt 0 ]]; then
    local prompt_title; prompt_title=$(title_for_mode "$MODE")
    echo "Resume previous ${prompt_title}? (y/N): "
    read -r ans
    if [[ "$ans" =~ ^[Yy]$ ]]; then
      MODE_TITLE=$(title_for_mode "$MODE")
      countdown_loop || return 1
      ACTIVE=0; save_state
      return 0
    fi
  fi
  return 1
}

# --- Menus ---
tasks_menu() {
  while true; do
    clear || true
    print_tasks
    echo -e "\nTasks menu:\n 1) Add task\n 2) Mark done\n 3) Cancel task\n 4) Delete task\n 5) Clear task list\n 6) Back"
    read -rp "Choose: " c || true
    case "$c" in
      1) add_tasks_interactive ;;
      2) mark_done ;;
      3) mark_cancelled ;;
      4) delete_task ;;
      5) clear_tasklist ;;
      6) break ;;
    esac
  done
}

main_menu() {
  load_tasks; load_state
  while true; do
    clear || true
    printf "%s %s\n\n" "$APP_NAME" "$TOMATO"
    print_tasks
    echo -e "\nMenu:\n 1) Start Pomodoro\n 2) Short Break\n 3) Long Break\n 4) Manage Tasks\n 5) Exit"
    read -rp "Choose an option: " choice || true
    case "$choice" in
      1)
        load_tasks; load_state
        # If we have saved remaining time, resume it automatically (even if ACTIVE flipped)
        if (( ${REMAINING:-0} > 0 )); then
          MODE_TITLE=$(title_for_mode "$MODE")
          if (( ACTIVE_TASK_INDEX >= 0 && ACTIVE_TASK_INDEX < ${#TASKS[@]:-0} )); then
            entry="${TASKS[$ACTIVE_TASK_INDEX]}"; name=${entry#*|}
            printf "Resuming %s %d: %s\n" "$MODE_TITLE" "$((ACTIVE_TASK_INDEX+1))" "$name"
          else
            printf "Resuming %s\n" "$MODE_TITLE"
          fi
          # Show resume-specific instruction message and start paused
          echo "Press 'p' to pause, 'r' to resume, 'q' to quit, 'Esc' for menu."
          printf "%s - %s - %s remaining - %s %s" \
            "$TOMATO" "$MODE_TITLE" "$(format_mmss "$REMAINING")" \
            "$(status_tag Paused \"$RED\")" "$(mode_tag "$MODE")"
          # Wait until user explicitly resumes or exits
          while true; do
            read -rsn1 k2
            if [ "$k2" = "r" ]; then
              # Flash a yellow [Resume] tag briefly with mode, then redraw normal line
              printf "\r\033[K%s - %s - %s remaining - %s %s" \
                "$TOMATO" "$MODE_TITLE" "$(format_mmss "$REMAINING")" \
                "$(status_tag Resume \"$YELLOW\")" "$(mode_tag "$MODE")"
              sleep 0.35
              printf "\r\033[K%s - %s - %s remaining" \
                "$TOMATO" "$MODE_TITLE" "$(format_mmss "$REMAINING")"
              break
            elif [ "$k2" = $'\e' ] || [ "$k2" = "q" ]; then
              echo
              read -rp "Press Enter..." _
              continue 2
            fi
          done
          # Now run the live countdown
          countdown_loop || true
          ACTIVE=0; save_state
          read -rp "Press Enter..." _
          continue
        fi
        # Otherwise ensure there's at least one pending task
        local pending_idx; pending_idx=$(first_pending_index)
        if (( pending_idx == -1 )); then
          echo "No tasks found. Let's add some first."
          add_tasks_interactive
          read -rp "Returning to main menu. Press Enter..." _
          continue
        fi
        ACTIVE_TASK_INDEX=$pending_idx; save_state
        MODE_TITLE="Work session"; start_session "$POMODORO_DURATION" work "$MODE_TITLE" || true
        if (( REMAINING==0 )); then complete_work_flow || true; fi
        read -rp "Press Enter..." _
        ;;
      2)
        MODE_TITLE="Short break"; start_session "$SHORT_BREAK" short "$MODE_TITLE" || true
        read -rp "Press Enter..." _
        ;;
      3)
        MODE_TITLE="Long break"; start_session "$LONG_BREAK" long "$MODE_TITLE" || true
        read -rp "Press Enter..." _
        ;;
      4)
        tasks_menu
        ;;
      5)
        # Persist current state before exiting
        save_state
        echo "Goodbye!"; exit 0
        ;;
    esac
  done
}

main_menu
